{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Mangum Mangum is an adapter for running ASGI applications in AWS Lambda to handle Function URL, API Gateway, ALB, and Lambda@Edge events. Documentation : https://mangum.fastapiexpert.com/ Features Event handlers for API Gateway HTTP and REST APIs, Application Load Balancer , Function URLs , and CloudFront Lambda@Edge . Compatibility with ASGI application frameworks, such as Starlette , FastAPI , Quart and Django . Support for binary media types and payload compression in API Gateway using GZip or Brotli. Works with existing deployment and configuration tools, including Serverless Framework and AWS SAM . Startup and shutdown lifespan events. Installation pip install mangum Example from mangum import Mangum async def app ( scope , receive , send ): await send ( { \"type\" : \"http.response.start\" , \"status\" : 200 , \"headers\" : [[ b \"content-type\" , b \"text/plain; charset=utf-8\" ]], } ) await send ({ \"type\" : \"http.response.body\" , \"body\" : b \"Hello, world!\" }) handler = Mangum ( app , lifespan = \"off\" ) Or using a framework: from fastapi import FastAPI from mangum import Mangum app = FastAPI () @app . get ( \"/\" ) def read_root (): return { \"Hello\" : \"World\" } @app . get ( \"/items/ {item_id} \" ) def read_item ( item_id : int , q : str = None ): return { \"item_id\" : item_id , \"q\" : q } handler = Mangum ( app , lifespan = \"off\" )","title":"Introduction"},{"location":"#mangum","text":"Mangum is an adapter for running ASGI applications in AWS Lambda to handle Function URL, API Gateway, ALB, and Lambda@Edge events. Documentation : https://mangum.fastapiexpert.com/","title":"Mangum"},{"location":"#features","text":"Event handlers for API Gateway HTTP and REST APIs, Application Load Balancer , Function URLs , and CloudFront Lambda@Edge . Compatibility with ASGI application frameworks, such as Starlette , FastAPI , Quart and Django . Support for binary media types and payload compression in API Gateway using GZip or Brotli. Works with existing deployment and configuration tools, including Serverless Framework and AWS SAM . Startup and shutdown lifespan events.","title":"Features"},{"location":"#installation","text":"pip install mangum","title":"Installation"},{"location":"#example","text":"from mangum import Mangum async def app ( scope , receive , send ): await send ( { \"type\" : \"http.response.start\" , \"status\" : 200 , \"headers\" : [[ b \"content-type\" , b \"text/plain; charset=utf-8\" ]], } ) await send ({ \"type\" : \"http.response.body\" , \"body\" : b \"Hello, world!\" }) handler = Mangum ( app , lifespan = \"off\" ) Or using a framework: from fastapi import FastAPI from mangum import Mangum app = FastAPI () @app . get ( \"/\" ) def read_root (): return { \"Hello\" : \"World\" } @app . get ( \"/items/ {item_id} \" ) def read_item ( item_id : int , q : str = None ): return { \"item_id\" : item_id , \"q\" : q } handler = Mangum ( app , lifespan = \"off\" )","title":"Example"},{"location":"adapter/","text":"Adapter The heart of Mangum is the adapter class. It is a configurable wrapper that allows any ASGI application (or framework) to run in an AWS Lambda deployment. The adapter accepts a number of keyword arguments to configure settings related to logging, HTTP responses, ASGI lifespan, and API Gateway configuration. handler = Mangum ( app , lifespan = \"auto\" , api_gateway_base_path = None , custom_handlers = None , text_mime_types = None , ) All arguments are optional. Configuring an adapter instance class mangum.adapter. Mangum ( app , lifespan='auto' , api_gateway_base_path='/' , custom_handlers=None , text_mime_types=None , exclude_headers=None ) Creating an AWS Lambda handler The adapter can be used to wrap any application without referencing the underlying methods. It defines a __call__ method that allows the class instance to be used as an AWS Lambda event handler function. from mangum import Mangum from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) def read_root (): return { \"Hello\" : \"World\" } @app . get ( \"/items/ {item_id} \" ) def read_item ( item_id : int , q : str = None ): return { \"item_id\" : item_id , \"q\" : q } handler = Mangum ( app ) However, this is just one convention, you may also intercept events and construct the adapter instance separately. This may be useful if you need to implement custom event handling. The handler in the example above could be replaced with a function. def handler ( event , context ): if event . get ( \"some-key\" ): # Do something or return, etc. return asgi_handler = Mangum ( app ) response = asgi_handler ( event , context ) # Call the instance with the event arguments return response Retrieving the AWS event and context The AWS Lambda handler event and context arguments are made available to an ASGI application in the ASGI connection scope. scope [ 'aws.event' ] scope [ 'aws.context' ] For example, if you're using FastAPI it can be retrieved from the scope attribute of the request object. from fastapi import FastAPI from mangum import Mangum from starlette.requests import Request app = FastAPI () @app . get ( \"/\" ) def hello ( request : Request ): return { \"aws_event\" : request . scope [ \"aws.event\" ]} handler = Mangum ( app )","title":"Adapter"},{"location":"adapter/#adapter","text":"The heart of Mangum is the adapter class. It is a configurable wrapper that allows any ASGI application (or framework) to run in an AWS Lambda deployment. The adapter accepts a number of keyword arguments to configure settings related to logging, HTTP responses, ASGI lifespan, and API Gateway configuration. handler = Mangum ( app , lifespan = \"auto\" , api_gateway_base_path = None , custom_handlers = None , text_mime_types = None , ) All arguments are optional.","title":"Adapter"},{"location":"adapter/#configuring-an-adapter-instance","text":"class mangum.adapter. Mangum ( app , lifespan='auto' , api_gateway_base_path='/' , custom_handlers=None , text_mime_types=None , exclude_headers=None )","title":"Configuring an adapter instance"},{"location":"adapter/#creating-an-aws-lambda-handler","text":"The adapter can be used to wrap any application without referencing the underlying methods. It defines a __call__ method that allows the class instance to be used as an AWS Lambda event handler function. from mangum import Mangum from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) def read_root (): return { \"Hello\" : \"World\" } @app . get ( \"/items/ {item_id} \" ) def read_item ( item_id : int , q : str = None ): return { \"item_id\" : item_id , \"q\" : q } handler = Mangum ( app ) However, this is just one convention, you may also intercept events and construct the adapter instance separately. This may be useful if you need to implement custom event handling. The handler in the example above could be replaced with a function. def handler ( event , context ): if event . get ( \"some-key\" ): # Do something or return, etc. return asgi_handler = Mangum ( app ) response = asgi_handler ( event , context ) # Call the instance with the event arguments return response","title":"Creating an AWS Lambda handler"},{"location":"adapter/#retrieving-the-aws-event-and-context","text":"The AWS Lambda handler event and context arguments are made available to an ASGI application in the ASGI connection scope. scope [ 'aws.event' ] scope [ 'aws.context' ] For example, if you're using FastAPI it can be retrieved from the scope attribute of the request object. from fastapi import FastAPI from mangum import Mangum from starlette.requests import Request app = FastAPI () @app . get ( \"/\" ) def hello ( request : Request ): return { \"aws_event\" : request . scope [ \"aws.event\" ]} handler = Mangum ( app )","title":"Retrieving the AWS event and context"},{"location":"asgi-frameworks/","text":"Frameworks Mangum is intended to provide support to any ASGI ( Asynchronous Server Gateway Interface ) application or framework. The \"turtles all the way down\" principle of ASGI allows for a great deal of interoperability across many different implementations, so the adapter should \"just work\"* for any ASGI application or framework. * if it doesn't, then please open an issue . :) Background We can think about the ASGI framework support without referencing an existing implementation. There are no framework-specific rules or dependencies in the adapter class, and all applications will be treated the same. Let's invent an API for a non-existent microframework to demonstrate things further. This could represent any ASGI framework application: import mangum.adapter import framework from mangum import Mangum app = framework . applications . Application () @app . route ( \"/\" ) def endpoint ( request : framework . requests . Request ) -> dict : return { \"hi\" : \"there\" } handler = Mangum ( app ) None of the framework details are important here. The routing decorator, request parameter, and return value of the endpoint method could be anything. The app instance will be a valid app parameter for Mangum so long as the framework exposes an ASGI-compatible interface: class Application ( Protocol ): async def __call__ ( self , scope : Scope , receive : ASGIReceive , send : ASGISend ) -> None : ... Limitations An application or framework may implement behaviour that is incompatible with the limitations of AWS Lambda, and there may be additional configuration required depending on a particular deployment circumstance. In some cases it is possible to work around these limitations, but these kinds of limitations should generally be dealt with outside of Mangum itself. Frameworks The examples on this page attempt to demonstrate a basic implementation of a particular framework (usually from official documentation) to highlight the interaction with Mangum. Specific deployment tooling, infrastructure, external dependencies, etc. are not taken into account. Starlette Starlette is a lightweight ASGI framework/toolkit, which is ideal for building high performance asyncio services. Mangum uses it as a toolkit in tests. It is developed by Encode , a wonderful community and collection of projects that are forming the foundations of the Python async web ecosystem. Define an application: from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.routing import Route from mangum import Mangum async def homepage ( request ): return JSONResponse ({ 'hello' : 'world' }) routes = [ Route ( \"/\" , endpoint = homepage ) ] app = Starlette ( debug = True , routes = routes ) Then wrap it using Mangum: handler = Mangum ( app ) FastAPI FastAPI is a modern, fast (high-performance), web framework for building APIs with Python based on standard Python type hints. from fastapi import FastAPI from mangum import Mangum app = FastAPI () @app . get ( \"/\" ) def read_root (): return { \"Hello\" : \"World\" } @app . get ( \"/items/ {item_id} \" ) def read_item ( item_id : int , q : str = None ): return { \"item_id\" : item_id , \"q\" : q } handler = Mangum ( app ) Responder Responder is a familiar HTTP Service Framework for Python, powered by Starlette. The static_dir and templates_dir parameters must be set to none to disable Responder's automatic directory creation behaviour because AWS Lambda is a read-only file system - see the limitations section for more details. from mangum import Mangum import responder app = responder . API ( static_dir = None , templates_dir = None ) @app . route ( \"/ {greeting} \" ) async def greet_world ( req , resp , * , greeting ): resp . text = f \" { greeting } , world!\" handler = Mangum ( app ) The adapter usage for both FastAPI and Responder is the same as Starlette. However, this may be expected because they are built on Starlette - what about other frameworks? Quart Quart is a Python ASGI web microframework. It is intended to provide the easiest way to use asyncio functionality in a web context, especially with existing Flask apps. This is possible as the Quart API is a superset of the Flask API. from quart import Quart from mangum import Mangum app = Quart ( __name__ ) @app . route ( \"/hello\" ) async def hello (): return \"hello world!\" handler = Mangum ( app ) Sanic Sanic is a Python web server and web framework that's written to go fast. It allows the usage of the async/await syntax added in Python 3.5, which makes your code non-blocking and speedy. from sanic import Sanic from sanic.response import json from mangum import Mangum app = Sanic () @app . route ( \"/\" ) async def test ( request ): return json ({ \"hello\" : \"world\" }) handler = Mangum ( app ) Django Django is a high-level Python Web framework that encourages rapid development and clean, pragmatic design. It started introducing ASGI support in version 3.0 . Certain async capabilities are not yet implemented and planned for future releases, however it can still be used with Mangum and other ASGI applications at the outer application level. # asgi.py import os from mangum import Mangum from django.core.asgi import get_asgi_application os . environ . setdefault ( \"DJANGO_SETTINGS_MODULE\" , \"app.settings\" ) application = get_asgi_application () handler = Mangum ( application , lifespan = \"off\" ) This example looks a bit different than the others because it is based on Django's standard project configuration, but the ASGI behaviour is the same. Channels Channels is a project that takes Django and extends its abilities beyond HTTP - to handle WebSockets, chat protocols, IoT protocols, and more. It is the original driving force behind the ASGI specification. It currently does not support ASGI version 3, but you can convert the application from ASGI version 2 using the guarantee_single_callable method provided in asgiref . # asgi.py import os import django from channels.routing import get_default_application from asgiref.compatibility import guarantee_single_callable from mangum import Mangum os . environ . setdefault ( \"DJANGO_SETTINGS_MODULE\" , \"project.settings\" ) django . setup () application = get_default_application () wrapped_application = guarantee_single_callable ( application ) handler = Mangum ( wrapped_application , lifespan = \"off\" )","title":"ASGI Frameworks"},{"location":"asgi-frameworks/#frameworks","text":"Mangum is intended to provide support to any ASGI ( Asynchronous Server Gateway Interface ) application or framework. The \"turtles all the way down\" principle of ASGI allows for a great deal of interoperability across many different implementations, so the adapter should \"just work\"* for any ASGI application or framework. * if it doesn't, then please open an issue . :)","title":"Frameworks"},{"location":"asgi-frameworks/#background","text":"We can think about the ASGI framework support without referencing an existing implementation. There are no framework-specific rules or dependencies in the adapter class, and all applications will be treated the same. Let's invent an API for a non-existent microframework to demonstrate things further. This could represent any ASGI framework application: import mangum.adapter import framework from mangum import Mangum app = framework . applications . Application () @app . route ( \"/\" ) def endpoint ( request : framework . requests . Request ) -> dict : return { \"hi\" : \"there\" } handler = Mangum ( app ) None of the framework details are important here. The routing decorator, request parameter, and return value of the endpoint method could be anything. The app instance will be a valid app parameter for Mangum so long as the framework exposes an ASGI-compatible interface: class Application ( Protocol ): async def __call__ ( self , scope : Scope , receive : ASGIReceive , send : ASGISend ) -> None : ...","title":"Background"},{"location":"asgi-frameworks/#limitations","text":"An application or framework may implement behaviour that is incompatible with the limitations of AWS Lambda, and there may be additional configuration required depending on a particular deployment circumstance. In some cases it is possible to work around these limitations, but these kinds of limitations should generally be dealt with outside of Mangum itself.","title":"Limitations"},{"location":"asgi-frameworks/#frameworks_1","text":"The examples on this page attempt to demonstrate a basic implementation of a particular framework (usually from official documentation) to highlight the interaction with Mangum. Specific deployment tooling, infrastructure, external dependencies, etc. are not taken into account.","title":"Frameworks"},{"location":"asgi-frameworks/#starlette","text":"Starlette is a lightweight ASGI framework/toolkit, which is ideal for building high performance asyncio services. Mangum uses it as a toolkit in tests. It is developed by Encode , a wonderful community and collection of projects that are forming the foundations of the Python async web ecosystem. Define an application: from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.routing import Route from mangum import Mangum async def homepage ( request ): return JSONResponse ({ 'hello' : 'world' }) routes = [ Route ( \"/\" , endpoint = homepage ) ] app = Starlette ( debug = True , routes = routes ) Then wrap it using Mangum: handler = Mangum ( app )","title":"Starlette"},{"location":"asgi-frameworks/#fastapi","text":"FastAPI is a modern, fast (high-performance), web framework for building APIs with Python based on standard Python type hints. from fastapi import FastAPI from mangum import Mangum app = FastAPI () @app . get ( \"/\" ) def read_root (): return { \"Hello\" : \"World\" } @app . get ( \"/items/ {item_id} \" ) def read_item ( item_id : int , q : str = None ): return { \"item_id\" : item_id , \"q\" : q } handler = Mangum ( app )","title":"FastAPI"},{"location":"asgi-frameworks/#responder","text":"Responder is a familiar HTTP Service Framework for Python, powered by Starlette. The static_dir and templates_dir parameters must be set to none to disable Responder's automatic directory creation behaviour because AWS Lambda is a read-only file system - see the limitations section for more details. from mangum import Mangum import responder app = responder . API ( static_dir = None , templates_dir = None ) @app . route ( \"/ {greeting} \" ) async def greet_world ( req , resp , * , greeting ): resp . text = f \" { greeting } , world!\" handler = Mangum ( app ) The adapter usage for both FastAPI and Responder is the same as Starlette. However, this may be expected because they are built on Starlette - what about other frameworks?","title":"Responder"},{"location":"asgi-frameworks/#quart","text":"Quart is a Python ASGI web microframework. It is intended to provide the easiest way to use asyncio functionality in a web context, especially with existing Flask apps. This is possible as the Quart API is a superset of the Flask API. from quart import Quart from mangum import Mangum app = Quart ( __name__ ) @app . route ( \"/hello\" ) async def hello (): return \"hello world!\" handler = Mangum ( app )","title":"Quart"},{"location":"asgi-frameworks/#sanic","text":"Sanic is a Python web server and web framework that's written to go fast. It allows the usage of the async/await syntax added in Python 3.5, which makes your code non-blocking and speedy. from sanic import Sanic from sanic.response import json from mangum import Mangum app = Sanic () @app . route ( \"/\" ) async def test ( request ): return json ({ \"hello\" : \"world\" }) handler = Mangum ( app )","title":"Sanic"},{"location":"asgi-frameworks/#django","text":"Django is a high-level Python Web framework that encourages rapid development and clean, pragmatic design. It started introducing ASGI support in version 3.0 . Certain async capabilities are not yet implemented and planned for future releases, however it can still be used with Mangum and other ASGI applications at the outer application level. # asgi.py import os from mangum import Mangum from django.core.asgi import get_asgi_application os . environ . setdefault ( \"DJANGO_SETTINGS_MODULE\" , \"app.settings\" ) application = get_asgi_application () handler = Mangum ( application , lifespan = \"off\" ) This example looks a bit different than the others because it is based on Django's standard project configuration, but the ASGI behaviour is the same.","title":"Django"},{"location":"asgi-frameworks/#channels","text":"Channels is a project that takes Django and extends its abilities beyond HTTP - to handle WebSockets, chat protocols, IoT protocols, and more. It is the original driving force behind the ASGI specification. It currently does not support ASGI version 3, but you can convert the application from ASGI version 2 using the guarantee_single_callable method provided in asgiref . # asgi.py import os import django from channels.routing import get_default_application from asgiref.compatibility import guarantee_single_callable from mangum import Mangum os . environ . setdefault ( \"DJANGO_SETTINGS_MODULE\" , \"project.settings\" ) django . setup () application = get_default_application () wrapped_application = guarantee_single_callable ( application ) handler = Mangum ( wrapped_application , lifespan = \"off\" )","title":"Channels"},{"location":"contributing/","text":"Contributing to Mangum Hello. Contributions to this project are highly encouraged and appreciated. This document will outline some general guidelines for how to get started. Contents Contributing to Mangum Contents Creating a pull request Setting up the repository Developing the project locally Setup Test Coverage requirements Lint Code style and formatting Static type checking Using the issue tracker Technical support Feature requests Thank you Creating a pull request Non-trivial changes, especially those that could impact existing behaviour, should have an associated issue created for discussion. An issue isn't strictly required for larger changes, but it can be helpful to discuss first. Minor changes generally should not require a new issue and can be explained in the pull request description. Setting up the repository To create a pull request, you must first fork the repository in GitHub, then clone the fork locally. git clone git@github.com:<YOUR-USERNAME>/mangum.git Then add the upstream remote to keep the forked repo in sync with the original. cd mangum git remote add upstream git://github.com/jordaneremieff/mangum.git git fetch upstream Then to keep in sync with changes in the primary repository, you pull the upstream changes into your local fork. git pull upstream main Developing the project locally There are a few scripts in place to assist with local development, the following scripts are located in the /scripts directory: Setup Running the setup script will create a local Python virtual environment. It assumes that python3.7 is available in the path and will install the development dependencies located in requirements.txt . ./scripts/setup Alternatively, you may create a virtual environment and install the requirements manually: python -m venv venv . venv/bin/active pip install -r requirements.txt This environment is used to run the tests for Python versions 3.7, 3.8, 3.9, and 3.10. Test The test script will run all the test cases with PyTest using the path for the virtual environment created in the setup step (above). ./scripts/test It also runs Coverage to produce a code coverage report. Coverage requirements The coverage script is intended to fail under 100% test coverage, but this is not a strict requirement for contributions. Generally speaking at least one test should be included in a PR, but it is okay to use # pragma: no cover comments in the code to exclude specific coverage cases from the build. Lint The linting script will handle running mypy for static type checking, and black for code formatting. ./scripts/lint Code style and formatting Black formatting is required for all files with a maximum line-length of 88 (black's default) and double-quotes \" are preferred over single-quotes ' , otherwise there aren't specific style guidelines. Static type checking Mypy is used to handle static type checking in the build, and type annotations should be included when making changes or additions to the code. However, it is okay to use # type: ignore comments when it is unclear what type to use, or if the annotation required to pass the type checker significantly decreases readability. Using the issue tracker The issue tracker can be used for different types of discussion, but it is mainly intended for items that are relevant to this project specifically. Here are a few things you might consider before opening a new issue: Is this covered in the documentation ? Is there already a related issue in the tracker ? Is this a problem related to Mangum itself or a third-party dependency? It may still be perfectly valid to open an issue if one or more of these is true, but thinking about these questions might help reveal an existing answer sooner. Technical support You may run into problems running Mangum that are related to a deployment tool (e.g. Serverless Framework ), an ASGI framework (e.g. FastAPI ), or some other external dependency. It is okay to use the tracker to resolve these kinds of issues, but keep in mind that this project does not guaruntee support for all the features of any specific ASGI framework or external tool. Note : These issues will typlically be closed, but it is fine to continue discussion on a closed issue. These issues will be re-opened only if a problem is discovered in Mangum itself. Feature requests This project is intended to be small and focused on providing an adapter class for ASGI applications deployed in AWS Lambda. Feature requests related to this use-case will generally be considered, but larger features that increase the overall scope of Mangum are less likely to be included. If you have a large feature request, please make an issue with sufficient detail and it can be discussed. Some feature requests may end up being rejected initially and re-considered later. Thank you :)","title":"Contributing"},{"location":"contributing/#contributing-to-mangum","text":"Hello. Contributions to this project are highly encouraged and appreciated. This document will outline some general guidelines for how to get started.","title":"Contributing to Mangum"},{"location":"contributing/#contents","text":"Contributing to Mangum Contents Creating a pull request Setting up the repository Developing the project locally Setup Test Coverage requirements Lint Code style and formatting Static type checking Using the issue tracker Technical support Feature requests Thank you","title":"Contents"},{"location":"contributing/#creating-a-pull-request","text":"Non-trivial changes, especially those that could impact existing behaviour, should have an associated issue created for discussion. An issue isn't strictly required for larger changes, but it can be helpful to discuss first. Minor changes generally should not require a new issue and can be explained in the pull request description.","title":"Creating a pull request"},{"location":"contributing/#setting-up-the-repository","text":"To create a pull request, you must first fork the repository in GitHub, then clone the fork locally. git clone git@github.com:<YOUR-USERNAME>/mangum.git Then add the upstream remote to keep the forked repo in sync with the original. cd mangum git remote add upstream git://github.com/jordaneremieff/mangum.git git fetch upstream Then to keep in sync with changes in the primary repository, you pull the upstream changes into your local fork. git pull upstream main","title":"Setting up the repository"},{"location":"contributing/#developing-the-project-locally","text":"There are a few scripts in place to assist with local development, the following scripts are located in the /scripts directory:","title":"Developing the project locally"},{"location":"contributing/#setup","text":"Running the setup script will create a local Python virtual environment. It assumes that python3.7 is available in the path and will install the development dependencies located in requirements.txt . ./scripts/setup Alternatively, you may create a virtual environment and install the requirements manually: python -m venv venv . venv/bin/active pip install -r requirements.txt This environment is used to run the tests for Python versions 3.7, 3.8, 3.9, and 3.10.","title":"Setup"},{"location":"contributing/#test","text":"The test script will run all the test cases with PyTest using the path for the virtual environment created in the setup step (above). ./scripts/test It also runs Coverage to produce a code coverage report.","title":"Test"},{"location":"contributing/#coverage-requirements","text":"The coverage script is intended to fail under 100% test coverage, but this is not a strict requirement for contributions. Generally speaking at least one test should be included in a PR, but it is okay to use # pragma: no cover comments in the code to exclude specific coverage cases from the build.","title":"Coverage requirements"},{"location":"contributing/#lint","text":"The linting script will handle running mypy for static type checking, and black for code formatting. ./scripts/lint","title":"Lint"},{"location":"contributing/#code-style-and-formatting","text":"Black formatting is required for all files with a maximum line-length of 88 (black's default) and double-quotes \" are preferred over single-quotes ' , otherwise there aren't specific style guidelines.","title":"Code style and formatting"},{"location":"contributing/#static-type-checking","text":"Mypy is used to handle static type checking in the build, and type annotations should be included when making changes or additions to the code. However, it is okay to use # type: ignore comments when it is unclear what type to use, or if the annotation required to pass the type checker significantly decreases readability.","title":"Static type checking"},{"location":"contributing/#using-the-issue-tracker","text":"The issue tracker can be used for different types of discussion, but it is mainly intended for items that are relevant to this project specifically. Here are a few things you might consider before opening a new issue: Is this covered in the documentation ? Is there already a related issue in the tracker ? Is this a problem related to Mangum itself or a third-party dependency? It may still be perfectly valid to open an issue if one or more of these is true, but thinking about these questions might help reveal an existing answer sooner.","title":"Using the issue tracker"},{"location":"contributing/#technical-support","text":"You may run into problems running Mangum that are related to a deployment tool (e.g. Serverless Framework ), an ASGI framework (e.g. FastAPI ), or some other external dependency. It is okay to use the tracker to resolve these kinds of issues, but keep in mind that this project does not guaruntee support for all the features of any specific ASGI framework or external tool. Note : These issues will typlically be closed, but it is fine to continue discussion on a closed issue. These issues will be re-opened only if a problem is discovered in Mangum itself.","title":"Technical support"},{"location":"contributing/#feature-requests","text":"This project is intended to be small and focused on providing an adapter class for ASGI applications deployed in AWS Lambda. Feature requests related to this use-case will generally be considered, but larger features that increase the overall scope of Mangum are less likely to be included. If you have a large feature request, please make an issue with sufficient detail and it can be discussed. Some feature requests may end up being rejected initially and re-considered later.","title":"Feature requests"},{"location":"contributing/#thank-you","text":":)","title":"Thank you"},{"location":"external-links/","text":"External Links External links related to using Mangum. Deploying Python web apps as AWS Lambda functions is a tutorial that goes through every step involved in packaging and deploying a Python web application to AWS Lambda, including how to use Mangum to wrap an ASGI application. Deploy FastAPI applications to AWS Lambda is a quick tutorial about how to deploy FastAPI and Starlette applications to AWS Lambda using Mangum, including also a suggested approach by AWS about how to manage larger applications. If you're interested in contributing to this page, please reference this issue in a PR.","title":"External Links"},{"location":"external-links/#external-links","text":"External links related to using Mangum. Deploying Python web apps as AWS Lambda functions is a tutorial that goes through every step involved in packaging and deploying a Python web application to AWS Lambda, including how to use Mangum to wrap an ASGI application. Deploy FastAPI applications to AWS Lambda is a quick tutorial about how to deploy FastAPI and Starlette applications to AWS Lambda using Mangum, including also a suggested approach by AWS about how to manage larger applications. If you're interested in contributing to this page, please reference this issue in a PR.","title":"External Links"},{"location":"http/","text":"HTTP Mangum provides support for the following AWS HTTP Lambda Event Source: API Gateway ( Event Examples ) HTTP Gateway ( Event Examples ) Application Load Balancer (ALB) ( Event Examples ) CloudFront Lambda@Edge ( Event Examples ) from fastapi import FastAPI from fastapi.middleware.gzip import GZipMiddleware from mangum import Mangum app = FastAPI () app . add_middleware ( GZipMiddleware , minimum_size = 1000 ) @app . get ( \"/\" ) async def main (): return \"somebigcontent\" handler = Mangum ( app , TEXT_MIME_TYPES = [ \"application/vnd.some.type\" ]) Configuring binary responses Binary responses are determined using the Content-Type and Content-Encoding headers from the event request and a list of text MIME types. Text MIME types By default, all response data will be base64 encoded and include isBase64Encoded=True in the response except the following MIME types: application/json application/javascript application/xml application/vnd.api+json application/vnd.oai.openapi Additionally, any Content-Type header prefixed with text/ is automatically excluded. Compression If the Content-Encoding header is set to gzip or br , then a binary response will be returned regardless of MIME type. State machine The HTTPCycle is used by the adapter to communicate message events between the application and AWS. It is a state machine that handles the entire ASGI request and response cycle. HTTPCycle class mangum.protocols.http. HTTPCycle ( scope , body ) async run ( self , app ) async receive ( self ) async send ( self , message ) HTTPCycleState class mangum.protocols.http. HTTPCycleState ( *values ) The state of the ASGI http connection. * REQUEST - Initial state. The ASGI application instance will be run with the connection scope containing the http type. * RESPONSE - The http.response.start event has been sent by the application. The next expected message is the http.response.body event, containing the body content. An application may pass the more_body argument to send content in chunks, however content will always be returned in a single response, never streamed. * COMPLETE - The body content from the ASGI application has been completely read. A disconnect event will be sent to the application, and the response will be returned.","title":"HTTP"},{"location":"http/#http","text":"Mangum provides support for the following AWS HTTP Lambda Event Source: API Gateway ( Event Examples ) HTTP Gateway ( Event Examples ) Application Load Balancer (ALB) ( Event Examples ) CloudFront Lambda@Edge ( Event Examples ) from fastapi import FastAPI from fastapi.middleware.gzip import GZipMiddleware from mangum import Mangum app = FastAPI () app . add_middleware ( GZipMiddleware , minimum_size = 1000 ) @app . get ( \"/\" ) async def main (): return \"somebigcontent\" handler = Mangum ( app , TEXT_MIME_TYPES = [ \"application/vnd.some.type\" ])","title":"HTTP"},{"location":"http/#configuring-binary-responses","text":"Binary responses are determined using the Content-Type and Content-Encoding headers from the event request and a list of text MIME types.","title":"Configuring binary responses"},{"location":"http/#text-mime-types","text":"By default, all response data will be base64 encoded and include isBase64Encoded=True in the response except the following MIME types: application/json application/javascript application/xml application/vnd.api+json application/vnd.oai.openapi Additionally, any Content-Type header prefixed with text/ is automatically excluded.","title":"Text MIME types"},{"location":"http/#compression","text":"If the Content-Encoding header is set to gzip or br , then a binary response will be returned regardless of MIME type.","title":"Compression"},{"location":"http/#state-machine","text":"The HTTPCycle is used by the adapter to communicate message events between the application and AWS. It is a state machine that handles the entire ASGI request and response cycle.","title":"State machine"},{"location":"http/#httpcycle","text":"class mangum.protocols.http. HTTPCycle ( scope , body ) async run ( self , app ) async receive ( self ) async send ( self , message )","title":"HTTPCycle"},{"location":"http/#httpcyclestate","text":"class mangum.protocols.http. HTTPCycleState ( *values ) The state of the ASGI http connection. * REQUEST - Initial state. The ASGI application instance will be run with the connection scope containing the http type. * RESPONSE - The http.response.start event has been sent by the application. The next expected message is the http.response.body event, containing the body content. An application may pass the more_body argument to send content in chunks, however content will always be returned in a single response, never streamed. * COMPLETE - The body content from the ASGI application has been completely read. A disconnect event will be sent to the application, and the response will be returned.","title":"HTTPCycleState"},{"location":"lifespan/","text":"Lifespan Mangum supports the ASGI Lifespan protocol. This allows applications to define lifespan startup and shutdown event handlers. from mangum import Mangum from fastapi import FastAPI app = FastAPI () @app . on_event ( \"startup\" ) async def startup_event (): pass @app . on_event ( \"shutdown\" ) async def shutdown_event (): pass @app . get ( \"/\" ) def read_root (): return { \"Hello\" : \"World\" } handler = Mangum ( app , lifespan = \"auto\" ) Configuring Lifespan events Lifespan support is automatically determined unless explicitly turned on or off. A string value option is used to configure lifespan support, the choices are auto , on , and off . Options auto Application support for lifespan is inferred using the state transitions. Any error that occurs during startup will be logged and the ASGI application cycle will continue unless a lifespan.startup.failed event is sent. on Application support for lifespan is explicit . Any error that occurs during startup will be raised and a 500 response will be returned. off Application support for lifespan is ignored . The application will not enter the lifespan cycle context. Defaults to auto . State machine The LifespanCycle is a state machine that handles ASGI lifespan events intended to run before and after HTTP requests are handled. LifespanCycle class mangum.protocols.lifespan. LifespanCycle ( app , lifespan ) Manages the application cycle for an ASGI lifespan connection. app - An asynchronous callable that conforms to version 3.0 of the ASGI specification. This will usually be an ASGI framework application instance. lifespan - A string to configure lifespan support. Choices are auto , on , and off . Default is auto . state - An enumerated LifespanCycleState type that indicates the state of the ASGI connection. exception - An exception raised while handling the ASGI event. This may or may not be raised depending on the state. app_queue - An asyncio queue (FIFO) containing messages to be received by the application. startup_event - An asyncio event object used to control the application startup flow. shutdown_event - An asyncio event object used to control the application shutdown flow. async run ( self ) Calls the application with the lifespan connection scope. async receive ( self ) Awaited by the application to receive ASGI lifespan events. async send ( self , message ) Awaited by the application to send ASGI lifespan events. async startup ( self ) Pushes the lifespan startup event to the queue and handles errors. async shutdown ( self ) Pushes the lifespan shutdown event to the queue and handles errors. Context manager Unlike the HTTPCycle class, the LifespanCycle is also used as a context manager in the adapter class. If lifespan support is turned off, then the application never enters the lifespan cycle context. with ExitStack () as stack : # Ignore lifespan events entirely if the `lifespan` setting is `off`. if self . lifespan in ( \"auto\" , \"on\" ): asgi_cycle : typing . ContextManager = LifespanCycle ( self . app , self . lifespan ) stack . enter_context ( asgi_cycle ) The magic methods __enter__ and __exit__ handle running the async tasks that perform startup and shutdown functions. def __enter__ ( self ) -> None : \"\"\" Runs the event loop for application startup. \"\"\" self . loop . create_task ( self . run ()) self . loop . run_until_complete ( self . startup ()) def __exit__ ( self , exc_type : typing . Optional [ typing . Type [ BaseException ]], exc_value : typing . Optional [ BaseException ], traceback : typing . Optional [ types . TracebackType ], ) -> None : \"\"\" Runs the event loop for application shutdown. \"\"\" self . loop . run_until_complete ( self . shutdown ()) LifespanCycleState class mangum.protocols.lifespan. LifespanCycleState ( *values ) The state of the ASGI lifespan connection. CONNECTING - Initial state. The ASGI application instance will be run with the connection scope containing the lifespan type. STARTUP - The lifespan startup event has been pushed to the queue to be received by the application. SHUTDOWN - The lifespan shutdown event has been pushed to the queue to be received by the application. FAILED - A lifespan failure has been detected, and the connection will be closed with an error. UNSUPPORTED - An application attempted to send a message before receiving the lifespan startup event. If the lifespan argument is \"on\", then the connection will be closed with an error.","title":"Lifespan"},{"location":"lifespan/#lifespan","text":"Mangum supports the ASGI Lifespan protocol. This allows applications to define lifespan startup and shutdown event handlers. from mangum import Mangum from fastapi import FastAPI app = FastAPI () @app . on_event ( \"startup\" ) async def startup_event (): pass @app . on_event ( \"shutdown\" ) async def shutdown_event (): pass @app . get ( \"/\" ) def read_root (): return { \"Hello\" : \"World\" } handler = Mangum ( app , lifespan = \"auto\" )","title":"Lifespan"},{"location":"lifespan/#configuring-lifespan-events","text":"Lifespan support is automatically determined unless explicitly turned on or off. A string value option is used to configure lifespan support, the choices are auto , on , and off .","title":"Configuring Lifespan events"},{"location":"lifespan/#options","text":"auto Application support for lifespan is inferred using the state transitions. Any error that occurs during startup will be logged and the ASGI application cycle will continue unless a lifespan.startup.failed event is sent. on Application support for lifespan is explicit . Any error that occurs during startup will be raised and a 500 response will be returned. off Application support for lifespan is ignored . The application will not enter the lifespan cycle context. Defaults to auto .","title":"Options"},{"location":"lifespan/#state-machine","text":"The LifespanCycle is a state machine that handles ASGI lifespan events intended to run before and after HTTP requests are handled.","title":"State machine"},{"location":"lifespan/#lifespancycle","text":"class mangum.protocols.lifespan. LifespanCycle ( app , lifespan ) Manages the application cycle for an ASGI lifespan connection. app - An asynchronous callable that conforms to version 3.0 of the ASGI specification. This will usually be an ASGI framework application instance. lifespan - A string to configure lifespan support. Choices are auto , on , and off . Default is auto . state - An enumerated LifespanCycleState type that indicates the state of the ASGI connection. exception - An exception raised while handling the ASGI event. This may or may not be raised depending on the state. app_queue - An asyncio queue (FIFO) containing messages to be received by the application. startup_event - An asyncio event object used to control the application startup flow. shutdown_event - An asyncio event object used to control the application shutdown flow. async run ( self ) Calls the application with the lifespan connection scope. async receive ( self ) Awaited by the application to receive ASGI lifespan events. async send ( self , message ) Awaited by the application to send ASGI lifespan events. async startup ( self ) Pushes the lifespan startup event to the queue and handles errors. async shutdown ( self ) Pushes the lifespan shutdown event to the queue and handles errors.","title":"LifespanCycle"},{"location":"lifespan/#context-manager","text":"Unlike the HTTPCycle class, the LifespanCycle is also used as a context manager in the adapter class. If lifespan support is turned off, then the application never enters the lifespan cycle context. with ExitStack () as stack : # Ignore lifespan events entirely if the `lifespan` setting is `off`. if self . lifespan in ( \"auto\" , \"on\" ): asgi_cycle : typing . ContextManager = LifespanCycle ( self . app , self . lifespan ) stack . enter_context ( asgi_cycle ) The magic methods __enter__ and __exit__ handle running the async tasks that perform startup and shutdown functions. def __enter__ ( self ) -> None : \"\"\" Runs the event loop for application startup. \"\"\" self . loop . create_task ( self . run ()) self . loop . run_until_complete ( self . startup ()) def __exit__ ( self , exc_type : typing . Optional [ typing . Type [ BaseException ]], exc_value : typing . Optional [ BaseException ], traceback : typing . Optional [ types . TracebackType ], ) -> None : \"\"\" Runs the event loop for application shutdown. \"\"\" self . loop . run_until_complete ( self . shutdown ())","title":"Context manager"},{"location":"lifespan/#lifespancyclestate","text":"class mangum.protocols.lifespan. LifespanCycleState ( *values ) The state of the ASGI lifespan connection. CONNECTING - Initial state. The ASGI application instance will be run with the connection scope containing the lifespan type. STARTUP - The lifespan startup event has been pushed to the queue to be received by the application. SHUTDOWN - The lifespan shutdown event has been pushed to the queue to be received by the application. FAILED - A lifespan failure has been detected, and the connection will be closed with an error. UNSUPPORTED - An application attempted to send a message before receiving the lifespan startup event. If the lifespan argument is \"on\", then the connection will be closed with an error.","title":"LifespanCycleState"}]}